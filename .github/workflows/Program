/*complex[0].real  =  halfcomplex[0]		Coefficienti di Fourier codificati in halfcomplex con DIM dispari (DIM=5)
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1]
complex[1].imag  =  halfcomplex[2]
complex[2].real  =  halfcomplex[3]
complex[2].imag  =  halfcomplex[4]
complex[3].real  =  halfcomplex[3]
complex[3].imag  = -halfcomplex[4]
complex[4].real  =  halfcomplex[1]
complex[4].imag  = -halfcomplex[2]*/

/*complex[0].real  =  halfcomplex[0]		Coefficienti di Fourier codificati in halfcomplex con DIM pari (DIM=6)
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1]
complex[1].imag  =  halfcomplex[2]
complex[2].real  =  halfcomplex[3]
complex[2].imag  =  halfcomplex[4]
complex[3].real  =  halfcomplex[5]
complex[3].imag  =  0
complex[4].real  =  halfcomplex[3]
complex[4].imag  = -halfcomplex[4]
complex[5].real  =  halfcomplex[1]
complex[5].imag  = -halfcomplex[2]*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_fft_real.h>
#include <gsl/gsl_fft_halfcomplex.h>
#include <gsl/gsl_errno.h>
#define T0 0
#define dt 1.0/48000.0				/*Frequenza di campionamento degli audio aac usati*/

typedef double floable;					/*A cute name for a float-double choice*/

void gnuplot() {
	int n;
	FILE *gnu;
    	gnu = popen(" gnuplot ", "w");			/*Serve per aprire gnuplot*/

	fprintf(gnu, "set title 'Modulo dei coefficienti di Fourier' \n set ylabel 'Fourier' \n set xlabel 'Freq'  \nset grid \n set terminal x11\n");	/*Setto le impostazioni per i grafici*/
    	fprintf(gnu, " plot \'AmpFreq.dat\' with lines \n ");
    	fprintf(gnu, "set title 'Segnale' \n set ylabel 'Ampiezza' \n set xlabel 'Time' \nset grid \n set terminal x11 1#1\n");
	fprintf(gnu, "plot \'AmpTime.dat\' with lines \n ");
	fprintf(gnu, "set title 'Modulo dei coefficienti di Fourier filtrati' \n set ylabel 'Fourier' \n set xlabel 'Freq'  \nset grid \n set terminal x11 2#2\n");	/*Setto le impostazioni per i grafici*/
    	fprintf(gnu, " plot \'Filtered_fft.dat\' with lines \n ");
    	fprintf(gnu, "set title 'Segnale Filtrato' \n set ylabel 'Ampiezza' \n set xlabel 'Time'  \nset grid \n set terminal x11 3#3\n");	/*Setto le impostazioni per i grafici*/
    	fprintf(gnu, " plot \'Filtered_signal.dat\' with lines \n ");
    	fflush(gnu);
	while (1){
		printf("Premi 0 per chiudere Gnuplot: ");
		scanf("%d",&n);
		if (n==0){
    			pclose(gnu);
    			break;
    		}
    	}
}

void SIGNAL(floable *Time,int dim){			/*Algoritmo di conversione aac-numerico*/
    	int n;       
    	int16_t buf[dim];  
    	for(n=0;n<dim;n++){
    		buf[n]=0;
    	}   
    	FILE *pipein;
    	pipein = popen("ffmpeg -i 1000hz.aac -f s16le -ac 1 -", "r");
    	fread(buf, 2, dim, pipein);
    	pclose(pipein);
    	for(n=0;n<dim;n++){
    		Time[n]=1.0*buf[n];
    	}
}

void fft_halfcomplex_filter(floable *halfcomplex_coefficient, int stride, int n){ /*Funzione di filtro per lo spettro del segnalr*/
	int i;
	for (i=0;i<n;i++){
		halfcomplex_coefficient[i]/=pow(1.0001,0.5*i);
	}
}

floable fft_module_pack(floable *halfcomplex_coefficient, int ind, int stride, int n){		/*funzione per calcolare il modulo dell'iesimo coefficiente di Fourier*/
	int i;
	floable mod;
	if(ind<=(n+1)/2 && ind!=0){
    		mod = sqrt(halfcomplex_coefficient[(2 * ind - 1)*stride]*halfcomplex_coefficient[(2 * ind - 1)*stride]+halfcomplex_coefficient[(2 * ind)*stride]*halfcomplex_coefficient[(2 * ind)*stride]);
  	}
	else if(ind>(n+1)/2){
  		mod = sqrt(halfcomplex_coefficient[(2 * (n-ind) - 1)*stride]*halfcomplex_coefficient[(2 * (n-ind) - 1)*stride]+halfcomplex_coefficient[(2 *(n- ind))*stride]*halfcomplex_coefficient[(2 * (n-ind))*stride]);
  	}
	else if (ind == n - ind){
    		mod = abs(halfcomplex_coefficient[(n - 1)*stride]);
    	}
    	else if(ind==0){
    		mod = abs(halfcomplex_coefficient[0]);
    	}	
  	return mod;
}

floable MyInput(floable a){				/*Questa funzione la potremo usare per controllare che alcuni input siano maggiori di un certo valore*/
	floable num;
	int n;
	while(1){
		scanf("%lf", &num);
		if (num>=a){
			return num;
		}
		else if(num<a){
			printf("Insert a number >= than %f\n",a);
		}
		n++;
		if (n>100){
			printf("Unexpected Error");
			exit(1);
		}
	}
}

int main (void){
	const gsl_rng_type *T;				/*inizializzazione. Creo un generatore che devo settare su un seed*/ 		
  	int i, DIM, stride=1;
  	floable t, *Time, MyInput(floable), fft_module_pack(floable*,int,int,int);
  	void SIGNAL(floable*,int), fft_halfcomplex_filter(floable*,int,int),gnuplot();
  	gsl_rng *r;					/*definisco il seed*/
  	gsl_rng_env_setup();				/*funzione che uso per definire il seed*/
  	T = gsl_rng_default;				/*uso il default seed*/	
  	r = gsl_rng_alloc (T);				/*faccio in modo che le info sul vettore T siano immagazzinate nel blocco di memoria di r*/
  	printf("Dimensione vettore dei campioni: ");
  	DIM=1*MyInput(1);				/*Definisco la dimensione del mio segnale*/
  	Time=(floable*)malloc(sizeof(floable)*DIM);	/*Array che uso sia per il segnale che per il cambio di base negli halfcomplex*/
  	SIGNAL(Time,DIM);				/*Genero un segnale pulito da un file*/
  	
  	FILE *AMPINTIME;				
  	AMPINTIME=fopen("AmpTime.dat","w");		/*File per il vettore dei campioni nel dominio dei tempi*/
  	for (i = 0; i < DIM; i++){	
  		t=T0+i*dt;
    		floable v = gsl_ran_ugaussian (r);		/*uso il generatore di numeri random normale standard doppia precisione */	
    		Time[i]=Time[i]+2000*v;			/*Segnale generato con aggiunta di rumore gaussiano*/	  
		fprintf(AMPINTIME, " %.5e %.5e\n",t,Time[i]); 	
	}	
	fclose(AMPINTIME);
	gsl_rng_free (r);					/*libero lo spazio di memoria dei vettori usati*/
	
	gsl_fft_real_wavetable * real;
	gsl_fft_halfcomplex_wavetable * hc;
	gsl_fft_real_workspace * work;
	work = gsl_fft_real_workspace_alloc (DIM);
	real = gsl_fft_real_wavetable_alloc (DIM);
	gsl_fft_real_transform (Time, stride, DIM, real, work);	/*Passo dalla base del tempo alla base halfcomplex*/
	FILE *AMPINFREQ;
	AMPINFREQ=fopen("AmpFreq.dat","w");		/*File per il modulo dei coefficienti di Fourier*/
    	for (i = 0; i < DIM; i++){
		fprintf(AMPINFREQ, "%.5e %.5e\n",1.0*(i)/(DIM*dt), fft_module_pack(Time,i,stride,DIM));			/*scrivo su file il modulo dei coefficienti di Fourier*/
    	}
    	fclose(AMPINFREQ);
	gsl_fft_real_wavetable_free (real);
	
	fft_halfcomplex_filter(Time,stride,DIM);						/*Funzione per filtrare il segnale*/
	FILE *FILTERED_FFT;
	FILTERED_FFT=fopen("Filtered_fft.dat","w");	/*File per lo spettro filtrato*/
	for (i = 0; i < DIM; i++){
		fprintf(FILTERED_FFT, "%.5e %.5e\n",1.0*(i)/(DIM*dt), fft_module_pack(Time,i,stride,DIM));			/*scrivo su file il modulo dei coefficienti di Fourier filtrati*/
    	}	
    	fclose(FILTERED_FFT);
    	
	hc = gsl_fft_halfcomplex_wavetable_alloc (DIM);
	gsl_fft_halfcomplex_inverse (Time, stride, DIM, hc, work);
  	gsl_fft_halfcomplex_wavetable_free (hc);
  	gsl_fft_real_workspace_free (work);
  	FILE *FILTERED_SIGNAL;		
	FILTERED_SIGNAL=fopen("Filtered_signal.dat","w");	/*File per il segnale filtrato*/
  	for (i = 0; i < DIM; i++){
		fprintf(FILTERED_SIGNAL, "%.5e %.5e\n",T0+i*dt, Time[i]);			/*scrivo su file il modulo dei coefficienti di Fourier filtrati*/
    	}
    	free(Time);
    	fclose(FILTERED_SIGNAL);
    	
	gnuplot();						/*Plot dei files*/
	return 0;
}
