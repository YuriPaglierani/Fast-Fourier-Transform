#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#define T0 0
typedef double floable;				/*A cute name for a float-double choice*/

void SIGNAL(floable *AmpTime,int dim){		/*Qui ci andrà l'algoritmo di conversione mp3-numerico*/
	int i;
	for (i=0;i<dim;i++){
		AmpTime[i]=10*sin(2*M_PI*i*0.01);
	}
}

floable MyInput(floable a){				/*Questa funzione la potremo usare per controllare che alcuni input siano maggiori di un certo valore*/
	floable num;
	int n;
	while(1){
		scanf("%lf", &num);
		if (num>=a){
			return num;
		}
		else if(num<a){
			printf("Insert a number >= than %f\n",a);
		}
		n++;
		if (n++>100){
			printf("Unexpected Error");
			exit(1);
		}
	}
}
int main (void){
	const gsl_rng_type *T;				/*inizializzazione. Creo un generatore che devo settare su un seed*/ 		
  	int i,DIM;
  	floable dt=0.01,t,*AmpTime,MyInput(floable);
  	void SIGNAL(floable*,int);
  	gsl_rng *r;					/*, unsigned long int s*/	/*definisco il seed. se non c'è s allora il seed è di default*/
  	gsl_rng_env_setup();				/*funzione che uso per definire il seed*/
  	T = gsl_rng_default;				/*uso il default seed*/	
  	r = gsl_rng_alloc (T);				/*faccio in modo che le info sul vettore T siano immagazzinate nel blocco di memoria di r*/
  	FILE *AMPINTIME;				/*Ci sarà anche un AMPINFREQ*/
  	AMPINTIME=fopen("AmpTime.dat","w");
  	printf("Dimensione vettore dei campioni: ");
  	DIM=1*MyInput(1);
  	AmpTime=(floable*)malloc(sizeof(floable)*DIM);	/*Usiamo un puntatore invece di un array, in questo modo sfruttiamo l'allocazione dinamica*/
  	SIGNAL(AmpTime,DIM);
  	for (i = 0; i < DIM; i++){	
  		t=T0+i*dt;
    		floable v = gsl_ran_ugaussian (r);		/*uso il generatore di numeri random normale standard doppia precisione */
							/* double v = gsl_ran_gaussian (r,a);	uso il generatore di random gaussiano doppia precisione, con errore a */  
		printf ("Gaussian %f	Signal %f	Signal+Noise %f \n",v,AmpTime[i],AmpTime[i]+v);
		fprintf(AMPINTIME, " %.5f %.5f\n",t,AmpTime[i]+v); 	/*Segnale, Sin, Errore*/
	}	
	gsl_rng_free (r);				/*libero lo spazio di memoria dei vettori usati*/
	
	
							/*Codice per la FFT*/
	
	fclose(AMPINTIME);
	free(AmpTime);
	return 0;
}
